{"version":3,"sources":["function/debounce.js","function/findWarning.js","function/checkValue.js","function/sortGroups.js","function/checkValueGroup.js","modules/validation.js","function/typesValidation.js","function/configValidation.js","function/checkAttrGroup.js","classes/OutputErrors.js","classes/Store.js","classes/Validation.js"],"names":["debounce","func","threshold","arguments","length","undefined","atBeginning","timerId","rest","Array","_len","_key","apply","this","setTimeout","_this","findWarning","element","arr","name","type","mediateArray","forEach","item","configValidation","indexOf","push","error","checkValue","dataInput","storeErrors","Object","keys","i","data","config","instructions","message","getMessage","checker","typesValidation","result","validate","msg","some","set","sortGroups","listGroups","groups","sortForName","arrName","itemArr","forEachGroup","list","dataset","checkValueGroup","groupRadio","validation","forms","document","querySelectorAll","initValidation","prototype","call","Validation","types","input","value","test","isNaN","min","Number","max","checked","array","rezult","checkAttrGroup","OutputErrors","storeCreateElements","Map","errorNotificationElement","create","messages","firstElement","next","currentForm","closest","key","map","has","get","textContent","createErrorElement","notifyElement","classList","add","parentElement","removeChild","delete","size","submit","span","createElement","insertBefore","Store","outputErrors","outMessage","sortMessages","form","listInputElement","store","groupsElements","isFirst","registerHandlers","init","addEventListener","event","lang","documentElement","arrayInputElement","filter","datasetToArray","split","isGroup","index","preventDefault","_this3"],"mappings":"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","file":"index.min.js","sourcesContent":["/**\n * Perform function more than once,\n * Is not exceeded the interval between calls\n * @param {Function} func\n * @param {number=100} threshold\n * @param {boolean=false} atBeginning\n * @returns {Function}\n */\nfunction debounce(\n\tfunc,\n\tthreshold = 100,\n\tatBeginning = false\n)\n{\n\tlet timerId;\n\t\n\treturn function debounced( ...rest )\n\t{\n\t\tif ( timerId )\n\t\t{\n\t\t\tclearTimeout( timerId );\n\t\t}\n\t\telse if ( atBeginning )\n\t\t{\n\t\t\tfunc.apply( this, rest );\n\t\t}\n\t\t\n\t\ttimerId = setTimeout(\n\t\t\t() =>\n\t\t\t{\n\t\t\t\tif ( !atBeginning )\n\t\t\t\t{\n\t\t\t\t\tfunc.apply( this, rest );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttimerId = 0;\n\t\t\t},\n\t\t\tthreshold\n\t\t);\n\t}\n}\n\nexport {\n\tdebounce as default,\n}\n","import configValidation from './configValidation';\n\n/**\n * Find and out warnings\n * \n * @param element {HTMLInputElement}\n * @param arr {Array}\n * @returns mediateArray {Array}\n */\nfunction findWarning( element, arr )\n{\n\tconst name = element.name;\n\tconst type = element.type;\n\tconst mediateArray = [];\n\t\n\tarr.forEach(\n\t\t( item ) =>\n\t\t{\n\t\t\tif ( configValidation[type].indexOf( item ) !== -1 )\n\t\t\t{\n\t\t\t\tmediateArray.push( item );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Warning: field named \"${name}\" with type=\"${type}\". data-options can not contain check to \"${item}\"`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t);\n\t\n\treturn mediateArray;\n}\n\nexport {\n\tfindWarning as default,\n}\n","import typesValidation from './typesValidation';\n\n/**\n * Determines error on ordinary field\n * \n * @param dataInput {Object}\n * @param storeErrors {Map}\n * @returns storeErrors {Map}\n */\nfunction checkValue( dataInput, storeErrors )\n{\n\tconst length = Object.keys( dataInput ).length;\n\t\n\tfor ( let i = 0; i < length; i++ )\n\t{\n\t\tconst data = dataInput[i];\n\t\tconst element = data['input'];\n\t\tconst config = data['config'];\n\t\tconst instructions = `instructions-${data['lang']}`;\n\t\tlet message = '';\n\t\t\n\t\tconst getMessage = ( item ) =>\n\t\t{\n\t\t\tconst checker = typesValidation[item];\n\t\t\t\n\t\t\tif ( checker )\n\t\t\t{\n\t\t\t\tconst result = checker.validate( element );\n\t\t\t\n\t\t\t\tif ( !result )\n\t\t\t\t{\n\t\t\t\t\tconst msg = checker[instructions];\n\t\t\t\t\t\n\t\t\t\t\tmessage = msg;\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\t\n\t\tif ( config )\n\t\t{\n\t\t\tconfig.some( getMessage );\n\t\t}\n\t\t\n\t\tstoreErrors.set( element, message );\n\t}\n\t\n\treturn storeErrors;\n}\n\nexport {\n\tcheckValue as default,\n}\n","/**\n * Sort the field to check on groups\n * \n * @param listGroups {Array}\n * @returns arr {Array}\n */\nfunction sortGroups( listGroups )\n{\n\tconst groups = [];\n\t\n\tlistGroups.forEach(\n\t\t( item ) =>\n\t\t{\n\t\t\tconst name = sortForName( item );\n\t\t\t\n\t\t\tif ( groups.indexOf( name ) === -1 )\n\t\t\t{\n\t\t\t\tgroups.push( name );\n\t\t\t}\n\t\t}\n\t);\n\t\n\tconst arr = [];\n\t\n\tgroups.forEach(\n\t\t( arrName ) =>\n\t\t{\n\t\t\tconst itemArr = forEachGroup( arrName, listGroups );\n\t\t\t\n\t\t\tarr.push( itemArr );\n\t\t}\n\t);\n\t\n\treturn arr;\n}\n\n/**\n * It passes through the main list, and created groups to check\n * \n * @param arrName {String}\n * @param list {Array}\n * @returns arr {Array}\n */\nfunction forEachGroup( arrName, list )\n{\n\tconst arr = [];\n\t\n\tlist.forEach(\n\t\t( item ) =>\n\t\t{\n\t\t\tconst name = sortForName( item );\n\t\t\t\n\t\t\tif ( arrName === name )\n\t\t\t{\n\t\t\t\tarr.push( item );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t);\n\t\n\treturn arr;\n}\n\n/**\n * Detected field type and detected name of its group\n * \n * @param item {HTMLInputElement}\n * @returns name {String}\n */\nfunction sortForName( item )\n{\n\tconst type = item.type;\n\tlet name;\n\t\n\tif ( type === 'radio' )\n\t{\n\t\tname = item.name;\n\t}\n\telse if ( type === 'checkbox' )\n\t{\n\t\tconst dataset = item.dataset['groupname'];\n\t\t\n\t\tif ( dataset )\n\t\t{\n\t\t\tname = dataset;\n\t\t}\n\t}\n\t\n\treturn name;\n}\n\nexport {\n\tsortGroups as default,\n}\n","import typesValidation from './typesValidation';\n\n/**\n * Field group check\n * \n * @param groupRadio {Array}\n * @param storeErrors {Map}\n * @returns storeErrors {Map}\n */\nfunction checkValueGroup( groupRadio, storeErrors )\n{\n\tgroupRadio.forEach(\n\t\t( arr ) =>\n\t\t{\n\t\t\tconst message = getMessage( arr )\n\t\t\t\n\t\t\tstoreErrors.set( arr[0], message );\n\t\t}\n\t);\n\t\n\treturn storeErrors;\n}\n\n/**\n * Get message about error\n * \n * @param arr {Array}\n * @returns message {String}\n */\nfunction getMessage( arr )\n{\n\tconst instructions = `instructions-en`;\n\tlet message = '';\n\t\n\tconst checkValue = ( item ) =>\n\t{\n\t\tconst checker = typesValidation['isEmptyGroup'];\n\t\t\n\t\tif ( checker )\n\t\t{\n\t\t\tconst result = checker.validate( arr );\n\t\t\n\t\t\tif ( !result )\n\t\t\t{\n\t\t\t\tconst msg = checker[instructions];\n\t\t\t\t\n\t\t\t\tmessage = msg;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t};\n\t\n\tarr.some( checkValue );\n\t\n\treturn message;\n}\n\nexport {\n\tcheckValueGroup as default,\n}\n","import Validation from '../classes/Validation';\n\n/**\n * Find all forms on the page\n */\nfunction validation()\n{\n\tconst forms = document.querySelectorAll( 'form[data-validation=true]' );\n\t\n\tinitValidation( forms );\n}\n\n/**\n * The passing through of the list forms and creating an instance of the class for each form\n * \n * @param forms список форм {NodeListOf<HTMLFormElement>}\n */\nfunction initValidation( forms )\n{\n\tArray.prototype.forEach.call(\n\t\tforms,\n\t\t( item ) =>\n\t\t{\n\t\t\tnew Validation( item );\n\t\t}\n\t);\n}\n\nexport {\n\tvalidation as default,\n}\n","/**\n * Contains embedded objects that contain check methods and a description of errors\n * \n * types {Object} \n */\n\nconst types = {\n\t/**\n\t * Check field on the empty\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tisNonEmpty: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn input.value !== '';\n\t\t},\n\t\t'instructions-ru': 'это поле не может быть пустым.',\n\t\t'instructions-en': 'This field can not be empty.'\n\t},\n\t/**\n\t * Check on the entered letters without special characters\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tonlyLetters: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn !/[^a-zа-яё ]/gi.test( input.value );\n\t\t},\n\t\t'instructions-ru': 'значением может быть только буквы от \"а\" до \"я\".',\n\t\t'instructions-en': 'value can only be the letters \"a\" to \"z\".'\n\t},\n\t/**\n\t * Check of the number\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tisValidNumber: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn !isNaN( input.value );\n\t\t},\n\t\t'instructions-ru': 'значением может быть только число­, например 1, 3.14 или 2010',\n\t\t'instructions-en': 'value can only be a number, such as 1, 3.14 or 2010'\n\t},\n\t/**\n\t * Check for compliance with the number of not less than min and not more than max \n\t * (works if given and min and max at the input type = \"number\")\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tminMax: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\tconst min = Number( input.min );\n\t\t\tconst max = Number( input.max );\n\t\t\tconst value = Number( input.value );\n\t\t\t\n\t\t\tif ( min > value \n\t\t\t\t|| value > max )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t},\n\t\t'instructions-ru': 'значением может быть только число не меньше min и не больше max',\n\t\t'instructions-en': 'value can only be a number no less and no more than min max'\n\t},\n\t/**\n\t * Check for compliance of not less than min (for input type=\"number\")\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tmin: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\tconst min = Number( input.min );\n\t\t\tconst value = Number( input.value );\n\t\t\t\n\t\t\tif ( min > value )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t},\n\t\t'instructions-ru': 'значением может быть только число не меньше min',\n\t\t'instructions-en': 'value can only be a number not less than min'\n\t},\n\t/**\n\t * Check for compliance of not more than max (for input type = \"number\")\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tmax: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\tconst max = Number( input.max );\n\t\t\tconst value = Number( input.value );\n\t\t\t\n\t\t\tif ( value > max )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t},\n\t\t'instructions-ru': 'значением может быть только число не больше max',\n\t\t'instructions-en': 'value can only be a number not more than max'\n\t},\n\t/**\n\t * Check the validity of the entered email address\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tisEmailCorrect: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn /^.+@.+$/.test( input.value );\n\t\t},\n\t\t'instructions-ru': 'введите корректный email',\n\t\t'instructions-en': 'enter a valid email'\n\t},\n\t/**\n\t * Check on the validity of the entered phone number\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tisValidTel: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn !/[^0-9 .()*+-]/g.test( input.value );\n\t\t},\n\t\t'instructions-ru': 'введите корректный телефон',\n\t\t'instructions-en': 'enter a valid phone'\n\t},\n\t/**\n\t * Check on the validity of the entered url address\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tisValidUrl: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn /^(https?|s?ftp|file):\\/\\/[a-zа-яё_-]+[\\a-zа-яё\\.]{2,6}\\??([a-zа-яё_-]+)\\#?([a-zа-яё_-]+)/g.test( input.value );\n\t\t},\n\t\t'instructions-ru': 'введите корректный url',\n\t\t'instructions-en': 'enter a valid url'\n\t},\n\t/**\n\t * Check activation of the required field (for checkbox or radio)\n\t * \n\t * @param input {HTMLInputElement}\n\t * @returns true or false {boolean}\n\t */\n\tisRequired: {\n\t\tvalidate: function ( input )\n\t\t{\n\t\t\treturn input.checked;\n\t\t},\n\t\t'instructions-ru': 'для продолжения активируйте обязательное поле',\n\t\t'instructions-en': 'for to continue activate a mandatory field'\n\t},\n\t/**\n\t * Check the activation of elements of at least one of the groups (for checkbox or radio)\n\t * \n\t * @param array {Array}\n\t * @returns rezult {boolean}\n\t */\n\tisEmptyGroup: {\n\t\tvalidate: function( array )\n\t\t{\n\t\t\tconst rezult = array.some(\n\t\t\t\t( item ) =>\n\t\t\t\t{\n\t\t\t\t\tif ( item.checked )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\treturn rezult;\n\t\t},\n\t\t'instructions-ru': 'необходимо выбрать хоть один пункт',\n\t\t'instructions-en': 'you need to select at least one item'\n\t}\n};\n\nexport {\n\ttypes as default,\n}\n","/**\n * Checks distributed depending on the type of field\n * \n * config {Object}\n */\nconst config = {\n\t/** inpyt type=\"text\" */\n\ttext: [\n\t\t'isNonEmpty',\n\t\t'onlyLetters'\n\t],\n\t/** inpyt type=\"number\" */\n\tnumber: [\n\t\t'isNonEmpty',\n\t\t'isValidNumber',\n\t\t'minMax',\n\t\t'min',\n\t\t'max'\n\t],\n\t/** inpyt type=\"email\" */\n\temail: [\n\t\t'isNonEmpty',\n\t\t'isEmailCorrect'\n\t],\n\t/** inpyt type=\"password\" */\n\tpassword: [\n\t\t'isNonEmpty'\n\t],\n\t/** inpyt type=\"file\" */\n\tfile: [\n\t\t'isNonEmpty'\n\t],\n\t/** inpyt type=\"search\" */\n\tsearch: [\n\t\t'isNonEmpty',\n\t\t'onlyLetters'\n\t],\n\t/** inpyt type=\"tel\" */\n\ttel: [\n\t\t'isNonEmpty',\n\t\t'isValidTel'\n\t],\n\t/** inpyt type=\"url\" */\n\turl: [\n\t\t'isNonEmpty',\n\t\t'isValidUrl'\n\t],\n\t/** inpyt type=\"checkbox\" */\n\tcheckbox: [\n\t\t'isRequired',\n\t\t'group'\n\t],\n\t/** inpyt type=\"radio\" */\n\tradio: [\n\t\t'isRequired',\n\t\t'group'\n\t]\n};\n\nexport {\n\tconfig as default,\n}\n","/**\n * Determines field in the group or ordinary\n * \n * @param item {HTMLInputElement}\n * @returns true or false {boolean}\n */\nconst checkAttrGroup = ( item ) =>\n{\n\tif ( item === 'group' )\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nexport {\n\tcheckAttrGroup as default,\n}\n","/**\n * Out errors\n * \n * @class OutputErrors\n */\nclass OutputErrors\n{\n\t/**\n\t * Creates an instance of OutputErrors.\n\t * \n\t */\n\tconstructor()\n\t{\n\t\t/** Store created tooltips */\n\t\tthis.storeCreateElements = new Map();\n\t\t/** Object with input field and message about error */\n\t\tthis.errorNotificationElement = Object.create( null );\n\t}\n\t\n\t/**\n\t * Sort messages and follow actions them\n\t * \n\t * @param messages {Map}\n\t */\n\tsortMessages( messages )\n\t{\n\t\tconst firstElement = messages.keys().next().value;\n\t\tconst currentForm = firstElement.closest( 'form' );\n\t\t\n\t\tmessages.forEach(( value, key, map ) =>\n\t\t{\n\t\t\tconst element = key;\n\t\t\tconst message = value;\n\t\t\t\n\t\t\tif ( message )\n\t\t\t{\n\t\t\t\tif ( !this.storeCreateElements.has( element ))\n\t\t\t\t{\n\t\t\t\t\tthis.errorNotificationElement = {\n\t\t\t\t\t\tnewElement: this.createErrorElement( element, message ),\n\t\t\t\t\t\tmessage: message\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.storeCreateElements.set( element, this.errorNotificationElement );\n\t\t\t\t}\n\t\t\t\telse if ( this.storeCreateElements.get( element )['message'] !== message )\n\t\t\t\t{\n\t\t\t\t\tthis.storeCreateElements.get( element )['newElement'].textContent = message;\n\t\t\t\t\tthis.storeCreateElements.get( element )['message'] = message;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( this.storeCreateElements.has( element ))\n\t\t\t\t{\n\t\t\t\t\tconst notifyElement = this.storeCreateElements.get( element )['newElement'];\n\t\t\t\t\t\n\t\t\t\t\tnotifyElement.classList.add( 'hide' );\n\t\t\t\t\t\n\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t{\n\t\t\t\t\t\telement.parentElement.removeChild( notifyElement );\n\t\t\t\t\t\tthis.storeCreateElements.delete( element );\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tif ( this.storeCreateElements.size === 0 )\n\t\t{\n\t\t\tcurrentForm.submit();\n\t\t}\n\t}\n\t\n\t/**\n\t * Create tooltip with error\n\t * \n\t * @param element {HTMLInputElement}\n\t * @param message {String}\n\t * @returns span {HTMLSpanElement}\n\t */\n\tcreateErrorElement( element, message )\n\t{\n\t\tconst span = document.createElement( 'span' );\n\t\tspan.classList.add( 'notify' );\n\t\tsetTimeout(() => span.classList.add( 'show' ), 0);\n\t\tspan.textContent = message;\n\t\t\n\t\telement.parentElement.insertBefore( span, element );\n\t\t\n\t\treturn span;\n\t}\n}\n\nexport {\n\tOutputErrors as default,\n}\n","import OutputErrors from './OutputErrors';\n\n/**\n * Store\n * \n * @class Store\n */\nclass Store\n{\n\t/**\n\t * Creates an instance of Store.\n\t * \n\t */\n\tconstructor()\n\t{\n\t\tthis.outputErrors = new OutputErrors();\n\t}\n\t\n\t/**\n\t * Get messages\n\t * \n\t * @param messages {Map}\n\t */\n\tgetMessage( messages )\n\t{\n\t\tthis.outMessage( messages );\n\t}\n\t\n\t/**\n\t * Out messages\n\t * \n\t * @param messages {Map}\n\t */\n\toutMessage( messages )\n\t{\n\t\tthis.outputErrors.sortMessages( messages );\n\t}\n}\n\nexport {\n\tStore as default,\n}\n","import debounce from '../function/debounce';\nimport typesValidation from '../function/typesValidation';\nimport findWarning from '../function/findWarning';\nimport checkValue from '../function/checkValue';\nimport checkAttrGroup from '../function/checkAttrGroup';\nimport sortGroups from '../function/sortGroups';\nimport checkValueGroup from '../function/checkValueGroup';\nimport Store from './Store';\n\n/**\n* @class Validation\n * \n * The main class for validation form\n */\nclass Validation\n{\n\t/**\n\t * Creates an instance of Validation.\n\t * \n\t * @param form {HTMLFormElement}\n\t */\n\tconstructor( form )\n\t{\n\t\tthis.form = form;\n\t\tthis.listInputElement = form.querySelectorAll( \n\t\t\t`input[type=text], input[type=number], input[type=email], input[type=password], input[type=file], \n\t\t\tinput[type=search], input[type=tel], input[type=url], input[type=checkbox], input[type=radio]` );\n\t\t\n\t\tthis.store = new Store();\n\t\tthis.storeErrors = new Map();\n\t\t\n\t\tthis.groupsElements = [];\n\t\tthis.dataInput = Object.create( null );\n\t\t/** Is this first press to send form? */\n\t\tthis.isFirst = true;\n\t\t\n\t\tthis.registerHandlers();\n\t}\n\t\n\t/**\n\t * Registed handlers\n\t */\n\tregisterHandlers()\n\t{\n\t\tthis.init();\n\t\tthis.form.addEventListener( 'submit', ( event ) => this.validation( event ) );\n\t}\n\t\n\t/**\n\t * Passes through the list of forms of gathering data about each\n\t */\n\tinit()\n\t{\n\t\tconst lang = document.documentElement.lang;\n\t\tconst arrayInputElement = [];\n\t\tconst listGroups = [];\n\t\t\n\t\tArray.prototype.filter.call(\n\t\t\tthis.listInputElement,\n\t\t\t( input ) =>\n\t\t\t{\n\t\t\t\tconst dataset = input.dataset['options'];\n\t\t\t\t\n\t\t\t\tif ( dataset )\n\t\t\t\t{\n\t\t\t\t\tif ( input.type === 'radio' \n\t\t\t\t\t\t|| input.type === 'checkbox' )\n\t\t\t\t\t{\n\t\t\t\t\t\tconst datasetToArray = dataset.split(' ');\n\t\t\t\t\t\tconst config = findWarning( input, datasetToArray );\n\t\t\t\t\t\tconst isGroup = datasetToArray.some( checkAttrGroup );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( isGroup )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlistGroups.push( input );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tarrayInputElement.push( input );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayInputElement.push( input );\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\tthis.groupsElements = sortGroups( listGroups );\n\t\t\n\t\tarrayInputElement.forEach(\n\t\t\t( input, index ) =>\n\t\t\t{\n\t\t\t\tconst dataset = input.dataset['options'];\n\t\t\t\tlet config;\n\t\t\t\t\n\t\t\t\tif ( dataset )\n\t\t\t\t{\n\t\t\t\t\tconst datasetToArray = dataset.split(' ');\n\t\t\t\t\t\n\t\t\t\t\tconfig = findWarning( input, datasetToArray );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.dataInput[index] = {\n\t\t\t\t\tinput: input,\n\t\t\t\t\tname: input.name,\n\t\t\t\t\tconfig: config,\n\t\t\t\t\tlang: lang\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\t/**\n\t * Checks forms\n\t * \n\t * @param event {Event}\n\t */\n\tvalidation( event )\n\t{\n\t\tevent.preventDefault();\n\t\t\n\t\t/** check the ordinary fields */\n\t\tlet storeErrors = checkValue( this.dataInput, this.storeErrors );\n\t\t\n\t\t/** checking the group fields */\n\t\tstoreErrors = checkValueGroup( this.groupsElements, this.storeErrors );\n\t\t\n\t\tthis.store.getMessage( storeErrors );\n\t\t\n\t\tif ( this.isFirst )\n\t\t{\n\t\t\tthis.form.addEventListener( 'input', debounce(( event ) => this.validation( event ), 100, true));\n\t\t\tthis.form.addEventListener( 'change', debounce(( event ) => this.validation( event ), 100, true));\n\t\t\tthis.isFirst = false;\n\t\t}\n\t}\n}\n\nexport {\n\tValidation as default,\n}\n"]}